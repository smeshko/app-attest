//
//  API.swift
//  
//
//  Created by Ian Sampson on 2020-12-21.
//

import Foundation
import Crypto

/// A namespace for functions that verify attestations and assertions
/// generated by Apple’s App Attest service.
public enum AppAttest { }

// TODO: Add a landing page for DocC
// with a description of the package.


// MARK: - Attestation

extension AppAttest {
    public enum Step: CaseIterable {
        /// Verify that the x5c array contains the intermediate and leaf certificates for App Attest, starting from the credential
        /// certificate in the first data buffer in the array (credcert). Verify the validity of the certificates using Apple’s App Attest
        /// root certificate.
        case verifyCertificates
        /// Create clientDataHash as the SHA256 hash of the one-time challenge your server sends to your app before
        /// performing the attestation, and append that hash to the end of the authenticator data (authData from the decoded
        /// object).
        ///
        /// Generate a new SHA256 hash of the composite item to create nonce.
        ///
        /// Obtain the value of the credCert extension with OID 1.2.840.113635.100.8.2, which is a DER-encoded ASN.1
        /// sequence. Decode the sequence and extract the single octet string that it contains. Verify that the string equals
        /// nonce.
        case verifyChallenge
        /// Create the SHA256 hash of the public key in credCert, and verify that it matches the key identifier from your app.
        case compareKeyID
        /// Compute the SHA256 hash of your app’s App ID, and verify that it’s the same as the authenticator data’s RP ID hash.
        case verifyAppID
        /// Verify that the authenticator data’s counter field equals 0.
        case verifyCounter
        /// Verify that the authenticator data’s aaguid field is either appattestdevelop if operating in the development
        /// environment, or appattest followed by seven 0x00 bytes if operating in the production environment.
        case verifyAAGUID
        /// Verify that the authenticator data’s credentialId field is the same as the key identifier.
        case verifyKeyID
    }
    
    /// A request to verify an attestation and its associated public key.
    ///
    /// `AttestationRequest` encapsulates the attestation submitted
    /// by a client app for verification.
    public struct AttestationRequest: Codable {
        /// The attestation object generated by the App Attest service.
        public let attestation: Data
        
        /// The public key identifier associated with the client app.
        public let keyID: Data
        
        /// Creates an `AttestationRequest` with the given attestation and key identifier.
        public init(attestation: Data, keyID: Data) {
            self.attestation = attestation
            self.keyID = keyID
        }
    }
    
    /// A verified attestation.
    ///
    /// The `verifyAttestation` function returns this result
    /// when attestation succeeds. Store the public key and receipt
    /// on your server for later use.
    public struct AttestationResult {
        /// The public key associated with the client app.
        public let publicKey: P256.Signing.PublicKey
        
        /// A receipt that can be used in a server-to-server call
        /// to request a fraud assessment metric from Apple.
        public let receipt: Data
    }
    
    /// Verifies an attestation generated by the App Attest service.
    ///
    /// - parameter challenge:
    /// The challenge previously generated and stored by the server
    /// in response to a request from the client app.
    ///
    /// - parameter request:
    /// A request that encapsulates the attestation submitted
    /// by a client app for verification.
    ///
    /// - parameter appID:
    /// The app identifier, which comprises
    /// the developer’s team identifier and the app’s bundle identifier.
    ///
    /// - parameter date:
    /// The date the attestation was generated.
    /// If `nil`, the current date is used.
    /// Only use this parameter for testing,
    /// and never trust a date submitted
    /// by the client app.
    ///
    /// - returns:
    /// A verified attestation, which contains a public key
    /// and a receipt that can be used for further verification.
    /// Store this result on your server for later use.
    public static func verifyAttestation(
        challenge: Data,
        request: AttestationRequest,
        appID: AppID,
        date: Date? = nil,
        steps: [Step] = Step.allCases
    ) throws -> AttestationResult {
        let attestation = try Attestation(data: request.attestation)
        let certificate = attestation.statement.certificates[0]
        
        guard let publicKeyData = certificate.publicKey else {
            throw Attestation.ValidationError.invalidPublicKey
            // Or .missingPublicKey
        }
        let publicKey = try P256.Signing.PublicKey(x963Representation: publicKeyData)
        
        try attestation.verify(
            challenge: challenge,
            appID: appID.description,
            keyID: request.keyID,
            date: date,
            steps: steps
        )
        // TODO: Pass in publicKey as an argument.
        
        return AttestationResult(
            publicKey: publicKey,
            receipt: attestation.statement.receipt
        )
    }
}


// MARK: - Assertion

extension AppAttest {
    /// A request to verify an assertion and its associated client data.
    ///
    /// `AssertionRequest` encapsulates the assertion submitted
    /// by a client app for verification.
    public struct AssertionRequest: Codable {
        /// The assertion object generated by the App Attest service.
        public let assertion: Data
        
        /// The client data submitted alongside the assertion request.
        public let clientData: Data
        
        /// The challenge generated by the server in response
        /// to a request from the client app.
        public let challenge: Data
        // TODO: Disambiguate this instance of the challenge
        // from the one submitted in the `verifyAssertion` call.
        
        /// Creates an `AssertionRequest` with the given assertion object, client data, and challenge.
        public init(assertion: Data, clientData: Data, challenge: Data) {
            self.assertion = assertion
            self.clientData = clientData
            self.challenge = challenge
        }
    }
    // TODO: Consider namespacing this struct
    // Assertion.ClientResponse
    // Assertion.Challenge.Response
    // TODO: Correct readme, which omits challenge and clientData
    
    /// A verified assertion.
    ///
    /// The `verifyAssertion` function returns this result
    /// when assertion succeeds. Store the result on your server
    /// for subsequent calls to `verifyAssertion`.
    public struct AssertionResult {
        /// A value that reports the number of times your app has used the attested key to sign an assertion.
        /// The `verifyAssertion` function extracts this value from the authenticator data
        /// contained in the assertion object and ensures that it is greater than the previous counter.
        public let counter: Int
    }
    // TODO: Consider including an identifier
    // (for example, the public key identifier)
    // that will make it easier to store this result
    // and retrieve it later.
    // TODO: Either make `counter` public or make AssertionResult
    // conform to Codable so that it can be stored in a database.
    
    /// Verifies an assertion generated by the App Attest service.
    ///
    /// - parameter challenge:
    /// The challenge previously generated and stored by the server
    /// in response to a request from the client app.
    ///
    /// - parameter request:
    /// A request that encapsulates the assertion submitted
    /// by a client app for verification.
    ///
    /// - parameter previousResult:
    /// The result of the most recent assertion
    /// by this instance of the client app. If this is the first assertion,
    /// use `nil`.
    ///
    /// - parameter publicKey: The public key for this client app,
    /// returned by `verifyAttestation`.
    ///
    /// - parameter appID:
    /// The app identifier, which comprises
    /// the developer’s team identifier and the app’s bundle identifier.
    ///
    /// - returns:
    /// A verified attestation, which contains a public key
    /// and a receipt that can be used for further verification.
    /// Store this result on your server for later use.
    public static func verifyAssertion(
        challenge: Data,
        request: AssertionRequest,
        previousResult: AssertionResult?,
        publicKey: P256.Signing.PublicKey,
        appID: AppID
    ) throws -> AssertionResult {
        let assertion = try Assertion(cbor: request.assertion)
        try assertion.verify(
            clientData: request.clientData,
            publicKey: publicKey,
            appID: appID.description,
            previousCounter: previousResult?.counter,
            receivedChallenge: request.challenge,
            storedChallenge: challenge
        )
        return AssertionResult(counter: Int(assertion.authenticatorData.counter))
    }
    // TODO: Add a reminder to use a different challenge
    // for attestation and assertion (and to never reuse a challenge).
}

extension AppAttest {
    /// The client’s app identifier,
    /// composed of the developer’s team identifier
    /// and the app’s bundle identifier.
    public struct AppID: Codable {
        /// The developer’s unique team identifier,
        /// which can be found in App Store Connect.
        public let teamID: String
        
        /// The bundle identifier for the client app.
        public let bundleID: String
        
        /// A string representation of the app identifier,
        /// used during the verification process.
        var description: String {
            "\(teamID).\(bundleID)"
        }
        
        /// Creates an `AppID` from the given team identifier and bundle identifier.
        public init(teamID: String, bundleID: String) {
            self.teamID = teamID
            self.bundleID = bundleID
        }
    }
    // TODO: Allow initialization with a String
    // or StringLiteral.
}
